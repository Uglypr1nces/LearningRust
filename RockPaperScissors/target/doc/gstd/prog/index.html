<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Functions and helpers for creating programs from programs."><title>gstd::prog - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="gstd" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0 (90b35a623 2024-11-26)" data-channel="1.83.0" data-search-js="search-f0d225181b97f9a4.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="icon" href="https://gear-tech.io/favicons/favicon.ico"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../gstd/index.html"><img src="https://docs.gear.rs/logo.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../gstd/index.html"><img src="https://docs.gear.rs/logo.svg" alt="logo"></a><h2><a href="../../gstd/index.html">gstd</a><span class="version">1.7.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module prog</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate gstd</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">gstd</a></span><h1>Module <span>prog</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/gstd/prog/mod.rs.html#19-45">source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Functions and helpers for creating programs from programs.</p>
<p>Any program being an actor, can not only process incoming messages and send
outcoming messages to other actors but also create new actors. This feature
can be useful when implementing the factory pattern, as a single
actor can produce multiple derived actors with different input data.</p>
<p>Firstly you need to upload a Wasm code of the future program(s) by calling
<code>gear.uploadCode</code> extrinsic to obtain the corresponding
<a href="../struct.CodeId.html" title="struct gstd::CodeId"><code>CodeId</code></a>.</p>
<p>You must also provide a unique byte sequence to create multiple program
instances from the same code. This sequence is often referenced as <em>salt</em>.
<a href="struct.ProgramGenerator.html" title="struct gstd::prog::ProgramGenerator"><code>ProgramGenerator</code></a> allows generating of salt automatically.</p>
<p>The newly created program should be initialized using a corresponding
payload; therefore, you must provide it when calling any <code>create_program_*</code>
function.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ProgramGenerator.html" title="struct gstd::prog::ProgramGenerator">Program<wbr>Generator</a></div><div class="desc docblock-short">Helper to create programs without setting the salt manually.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">ยง</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.create_program.html" title="fn gstd::prog::create_program">create_<wbr>program</a></div><div class="desc docblock-short">Same as <a href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes"><code>create_program_bytes</code></a>, but allows
initialize program with the encodable payload.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes">create_<wbr>program_<wbr>bytes</a></div><div class="desc docblock-short">Create a new program from the already existing on-chain code identified by
<a href="../struct.CodeId.html" title="struct gstd::CodeId"><code>CodeId</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_bytes_delayed.html" title="fn gstd::prog::create_program_bytes_delayed">create_<wbr>program_<wbr>bytes_<wbr>delayed</a></div><div class="desc docblock-short">Same as <a href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes"><code>create_program_bytes</code></a>, but creates a new program after the
<code>delay</code> expressed in block count.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_bytes_for_reply.html" title="fn gstd::prog::create_program_bytes_for_reply">create_<wbr>program_<wbr>bytes_<wbr>for_<wbr>reply</a></div><div class="desc docblock-short">Same as <a href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes"><code>create_program_bytes</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_bytes_for_reply_as.html" title="fn gstd::prog::create_program_bytes_for_reply_as">create_<wbr>program_<wbr>bytes_<wbr>for_<wbr>reply_<wbr>as</a></div><div class="desc docblock-short">Same as <a href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes"><code>create_program_bytes</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_bytes_with_gas.html" title="fn gstd::prog::create_program_bytes_with_gas">create_<wbr>program_<wbr>bytes_<wbr>with_<wbr>gas</a></div><div class="desc docblock-short">Same as <a href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes"><code>create_program_bytes</code></a>, but with an explicit gas limit.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_bytes_with_gas_delayed.html" title="fn gstd::prog::create_program_bytes_with_gas_delayed">create_<wbr>program_<wbr>bytes_<wbr>with_<wbr>gas_<wbr>delayed</a></div><div class="desc docblock-short">Same as <a href="fn.create_program_bytes_with_gas.html" title="fn gstd::prog::create_program_bytes_with_gas"><code>create_program_bytes_with_gas</code></a>, but creates a new program after
the <code>delay</code> expressed in block count.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_bytes_with_gas_for_reply.html" title="fn gstd::prog::create_program_bytes_with_gas_for_reply">create_<wbr>program_<wbr>bytes_<wbr>with_<wbr>gas_<wbr>for_<wbr>reply</a></div><div class="desc docblock-short">Same as <a href="fn.create_program_bytes_with_gas.html" title="fn gstd::prog::create_program_bytes_with_gas"><code>create_program_bytes_with_gas</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_bytes_with_gas_for_reply_as.html" title="fn gstd::prog::create_program_bytes_with_gas_for_reply_as">create_<wbr>program_<wbr>bytes_<wbr>with_<wbr>gas_<wbr>for_<wbr>reply_<wbr>as</a></div><div class="desc docblock-short">Same as <a href="fn.create_program_bytes_with_gas.html" title="fn gstd::prog::create_program_bytes_with_gas"><code>create_program_bytes_with_gas</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_delayed.html" title="fn gstd::prog::create_program_delayed">create_<wbr>program_<wbr>delayed</a></div><div class="desc docblock-short">Same as <a href="fn.create_program.html" title="fn gstd::prog::create_program"><code>create_program</code></a>, but creates a new program after the <code>delay</code>
expressed in block count.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_for_reply.html" title="fn gstd::prog::create_program_for_reply">create_<wbr>program_<wbr>for_<wbr>reply</a></div><div class="desc docblock-short">Same as <a href="fn.create_program.html" title="fn gstd::prog::create_program"><code>create_program</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_for_reply_as.html" title="fn gstd::prog::create_program_for_reply_as">create_<wbr>program_<wbr>for_<wbr>reply_<wbr>as</a></div><div class="desc docblock-short">Same as <a href="fn.create_program.html" title="fn gstd::prog::create_program"><code>create_program</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_with_gas.html" title="fn gstd::prog::create_program_with_gas">create_<wbr>program_<wbr>with_<wbr>gas</a></div><div class="desc docblock-short">Same as <a href="fn.create_program.html" title="fn gstd::prog::create_program"><code>create_program</code></a>, but with an explicit gas limit.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_with_gas_delayed.html" title="fn gstd::prog::create_program_with_gas_delayed">create_<wbr>program_<wbr>with_<wbr>gas_<wbr>delayed</a></div><div class="desc docblock-short">Same as <a href="fn.create_program_with_gas.html" title="fn gstd::prog::create_program_with_gas"><code>create_program_with_gas</code></a>, but creates a new program after the
<code>delay</code> expressed in block count.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_with_gas_for_reply.html" title="fn gstd::prog::create_program_with_gas_for_reply">create_<wbr>program_<wbr>with_<wbr>gas_<wbr>for_<wbr>reply</a></div><div class="desc docblock-short">Same as <a href="fn.create_program_with_gas.html" title="fn gstd::prog::create_program_with_gas"><code>create_program_with_gas</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.create_program_with_gas_for_reply_as.html" title="fn gstd::prog::create_program_with_gas_for_reply_as">create_<wbr>program_<wbr>with_<wbr>gas_<wbr>for_<wbr>reply_<wbr>as</a></div><div class="desc docblock-short">Same as <a href="fn.create_program_with_gas.html" title="fn gstd::prog::create_program_with_gas"><code>create_program_with_gas</code></a>, but the program
will interrupt until the reply is received.</div></li></ul></section></div></main></body></html>